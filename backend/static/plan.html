<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>학습 계획</title>

    <!-- React & ReactDOM -->
    <script src="https://unpkg.com/react@17/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@17/umd/react-dom.development.js" crossorigin></script>
    <!-- Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- Lucide Icons UMD -->
    <script src="https://cdn.jsdelivr.net/npm/lucide@latest/dist/umd/lucide.min.js"></script>
    <style>
    /* Basic Reset */
    * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
    /* Prevent selection, tap highlight on touch devices */
    user-select: none;
    -webkit-user-select: none; /* Safari */
    -ms-user-select: none; /* IE 10+ */
    -webkit-touch-callout: none; /* Prevent callout menu on iOS */
    -webkit-tap-highlight-color: transparent; /* Prevent tap highlight */
    }

    /* Body styles for centering and background */
    body {
    font-family: 'Pretendard', -apple-system, BlinkMacSystemFont, sans-serif;
    background-color: #FDF8F4; /* Light orange background */
    color: #333; /* Default text color */
    line-height: 1.5;
    max-width: 390px; /* Max width for content */
    margin: 0 auto; /* Center the body horizontally */
    min-height: 100vh;
    position: relative; /* For positioning absolute children (like add button) relative to body */
    overflow-y: auto; /* Default scroll behavior */
    overflow-x: hidden; /* Prevent horizontal scroll */
    }

    /* Class to disable scrolling on body */
    body.no-scroll {
    overflow-y: hidden;
    overscroll-behavior-y: contain; /* Prevent pull-to-refresh etc. */
    }

    /* Header style */
    .header {
    position: sticky;
    top: 0;
    width: 100%; /* Takes full width of the body (390px) */
    background-color: #fdf8f4; /* Match body background */
    padding: 12px 16px; /* Padding */
    border-bottom: 1px solid #e8ddd4; /* Bottom border */
    display: flex;
    justify-content: space-between; /* Space out logo and buttons */
    align-items: center;
    z-index: 1000; /* Above other content */
    transition: filter 0.3s ease; /* Smooth blur transition */
    }

    /* Header blur effect when modal is open */
    .header.blurred {
    filter: blur(3px);
    pointer-events: none; /* Disable clicks */
    }

    .logo {
    display: flex;
    align-items: center;
    font-size: 18px;
    font-weight: 700;
    color: #f96c50; /* Orange color */
    }

    .header-buttons { /* Container for header buttons */
    display: flex;
    gap: 8px; /* Gap between buttons */
    }

    .header-btn { /* Individual header button */
    background: none;
    border: none;
    padding: 8px;
    border-radius: 8px;
    color: #DD6B20; /* Darker orange color */
    cursor: pointer;
    transition: all 0.2s ease;
    }

    .header-btn:hover {
    transform: scale(1.05);
    }

    /* Main content area - holds schedule and AI views */
    /* This div slides left/right */
    .main-content {
    display: flex;
    height: 100%; /* Fill parent height */
    position: relative;
    overflow: hidden; /* Hide sliding content */
    }

    /* View container (schedule or AI) */
    .view-container {
    width: 100%; /* Each view takes full width of parent (390px) */
    position: relative;
    transition-property: transform;
    transition-duration: 300ms;
    transition-timing-function: ease; /* Match Tailwind duration-300 transition-transform */
    flex-shrink: 0; /* Prevent shrinking in flex container */
    }

    /* Schedule view position */
    .schedule-view {
    transform: translateX(0); /* Default position */
    }

    /* AI view position */
    .ai-view {
    position: absolute; /* Position AI view on top */
    top: 0;
    left: 100%; /* Start 100% to the right of its container */
    }

    /* AI view active state */
    .ai-view.active {
    transform: translateX(-100%); /* Slide left to cover schedule view */
    }
    /* Schedule view active state when AI view is showing */
    .schedule-view.shifted {
    transform: translateX(-100%); /* Slide left out of view */
    }

    /* Time grid background and padding */
    .time-grid {
    height: 100%; /* Fill parent height */
    background-color: #fff7ed; /* Light orange */
    /* Padding at the bottom to account for fixed footer */
    padding-bottom: 120px; /* Matches fixed-bottom-bar height roughly + buffer */
    }

    /* Style for each 30-min time slot row */
    .time-slot {
    display: flex;
    align-items: flex-start;
    height: 84px; /* slotHeight30 */
    border-bottom: 1px solid #e5e7eb; /* gray-200 border */
    }

    /* Special style for hour markers */
    .time-slot.is-hour {
    background-color: #ffffff; /* White background for hours */
    }

    .time-label {
    width: 64px; /* w-16 */
    text-align: center;
    color: #4b5563; /* gray-600 */
    font-weight: 500; /* font-medium */
    padding-top: 8px; /* pt-2 */
    }

    .time-content {
    flex: 1 1 0%; /* flex-1 */
    padding-left: 16px; /* pl-4 */
    }

    /* Plan card styles */
    .plan-card {
    position: absolute; /* Position over the grid */
    left: calc(64px + 4px); /* Time label width + padding */
    right: 16px; /* Right padding */
    border-width: 2px; /* border-2 */
    border-style: solid;
    background-color: white;
    border-radius: 12px; /* rounded-xl */
    box-shadow: 0 4px 8px rgba(0,0,0,0.1); /* shadow-md */
    overflow: hidden;
    z-index: 10; /* Above time grid */
    }

    .plan-card:hover {
    box-shadow: 0 8px 16px rgba(0,0,0,0.15); /* hover:shadow-lg */
    }

    .plan-card.is-done { /* Style for done plans */
    border-color: #d1fae5; /* green-300 */
    background-color: #f0fdf4; /* green-50 */
    }

    .plan-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 4px 12px; /* py-1 px-3 */
    /* Add pointer-events-none here and auto on children */
    pointer-events: none;
    }
    .plan-header > * { pointer-events: auto; } /* Allow clicks on children */


    .plan-title {
    display: flex;
    align-items: center;
    gap: 8px; /* gap-2 */
    }

    .plan-emoji {
    font-size: 24px; /* text-2xl */
    }

    .plan-title-text {
    font-weight: 500; /* font-medium */
    font-size: 14px; /* text-sm */
    }

    .plan-actions {
    display: flex;
    gap: 4px; /* gap-1 */
    }

    .plan-action-btn {
    background: none;
    border: none;
    padding: 4px; /* p-1 */
    border-radius: 4px; /* rounded */
    cursor: pointer;
    }

    .plan-action-btn:hover {
    background-color: #e5e7eb; /* hover:bg-gray-200 */
    }

    .plan-action-btn .lucide {
    pointer-events: none; /* Prevent icon from blocking button */
    }


    .plan-content {
    padding: 0 12px 8px; /* px-3 pb-2 */
    /* Add pointer-events-none here */
    pointer-events: none;
    }

    .plan-times,
    .plan-memo {
    font-size: 12px; /* text-xs */
    color: #6b7280; /* text-gray-500 / text-gray-600 */
    }
    .plan-memo {
    color: #4b5563; /* text-gray-600 */
    margin-top: 4px; /* Small space below time */
    }


    /* Style for resize handles */
    .resize-handle {
    position: absolute;
    left: 0;
    right: 0;
    height: 8px; /* Increased touch area */
    cursor: ns-resize;
    z-index: 20; /* Below buttons/icons, above card content */
    }

    .resize-handle.top {
    top: -4px; /* Position outside the card border for better touch */
    }

    .resize-handle.bottom {
    bottom: -4px; /* Position outside the card border for better touch */
    }

    /* AI View styles */
    .ai-view-content {
    padding: 16px; /* p-4 */
    height: 100%; /* Fill parent height */
    background-color: #fff7ed; /* Unified background color (matching time-grid) */
    padding-bottom: 120px; /* Padding for fixed footer */
    display: flex; /* Use flex for layout */
    flex-direction: column; /* Stack children vertically */
    }

    .ai-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 16px; /* mb-4 */
    flex-shrink: 0; /* Prevent header from shrinking */
    }

    .ai-title {
    font-size: 18px; /* text-lg */
    font-weight: 700; /* font-bold */
    display: flex;
    align-items: center;
    gap: 8px; /* gap-2 */
    }

    .ai-back-btn {
    color: #f59e0b; /* orange-600 */
    background: none;
    border: none;
    cursor: pointer;
    }
    .ai-back-btn:hover { text-decoration: underline; }

    .ai-plans-list {
    flex-grow: 1; /* Allow plan list to take available space */
    overflow-y: auto; /* Add scroll to the list if it overflows */
    display: flex;
    flex-direction: column;
    gap: 12px; /* space-y-3 */
    /* Add some padding if needed, considering the scrollbar */
    padding-right: 8px; /* Add padding for scrollbar visual separation */
    }

    .ai-plan-card {
    position: relative; /* Needed for absolute delete button */
    padding: 16px; /* p-4 */
    background-color: #f97316; /* orange-500 */
    color: white;
    border-radius: 12px; /* rounded-xl */
    box-shadow: 0 2px 4px rgba(0,0,0,0.05); /* shadow-sm */
    display: flex;
    align-items: center;
    gap: 12px; /* gap-3 */
    /* Adjust padding-right to make space for the delete button */
    padding-right: 40px; /* Add space for the button */
    flex-shrink: 0; /* Prevent cards from shrinking in the flex container */
    }

    .ai-plan-card.is-done {
    border-color: #d1fae5; /* green-300 */
    background-color: #f0fdf4; /* green-50 */
    }

    .ai-plan-emoji {
    font-size: 24px; /* text-2xl */
    }

    .ai-plan-details { /* Container for title and time */
    flex-grow: 1; /* Allow details to take space */
    }

    .ai-plan-details .title {
    font-weight: 500; /* font-medium */
    font-size: 15px; /* Slightly larger font */
    line-height: 1.3; /* Tighter line height for multi-line titles */
    }

    .ai-plan-details .time {
    font-size: 13px; /* text-sm */
    color: #ffedd5; /* orange-100 */
    margin-top: 4px; /* Space below title */
    }

    .ai-plan-delete-btn {
    position: absolute;
    top: 8px; /* Position from top */
    right: 8px; /* Position from right */
    background: none;
    border: none;
    font-size: 12px;
    color: rgba(255, 255, 255, 0.7); /* Slightly transparent white */
    cursor: pointer;
    padding: 4px; /* Clickable area */
    border-radius: 4px;
    z-index: 5; /* Ensure clickable */
    transition: color 0.2s ease;
    }
    .ai-plan-delete-btn:hover {
    color: white;
    }

    /* AI Empty State / Loading Indicator Container */
    .ai-center-container {
    flex-grow: 1; /* Take up space */
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center; /* Center vertically */
    text-align: center;
    padding: 32px 0; /* py-8 */
    color: #4b5563; /* gray-600 */
    }


    /* Loading Indicator Styles */
    .spinner {
    width: 40px; /* Spinner size */
    height: 40px;
    border: 4px solid #f3f3f3; /* Light grey border */
    border-top: 4px solid #f96c50; /* Orange border for animation */
    border-radius: 50%;
    animation: spin 1s linear infinite; /* Apply spinning animation */
    margin-bottom: 15px; /* Space between spinner and text */
    }

    @keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
    }

    .loading-text {
    font-size: 16px;
    margin-bottom: 5px;
    }

    .eta-text {
    font-size: 14px;
    color: #666;
    }


    .ai-generate-btn {
    background-color: #f97316; /* orange-500 */
    color: white;
    padding: 12px 24px; /* px-6 py-3 */
    border-radius: 9999px; /* rounded-full */
    border: none;
    font-weight: 700; /* font-bold */
    box-shadow: 0 4px 6px rgba(0,0,0,0.1); /* shadow-md */
    transition: all 0.2s ease; /* transition-all duration-200 */
    cursor: pointer;
    margin-top: 16px; /* Add some space */
    }
    .ai-generate-btn:hover {
    background-color: #ea580c; /* hover:bg-orange-600 */
    box-shadow: 0 8px 16px rgba(0,0,0,0.15); /* hover:shadow-lg */
    transform: scale(1.05); /* hover:scale-105 */
    }
    .ai-generate-btn:active {
    transform: scale(0.95); /* active:scale-95 */
    }

    /* Fixed bottom command bar */
    .fixed-bottom-bar {
    position: fixed;
    bottom: 0;
    left: 50%;
    transform: translateX(-50%); /* Center horizontally */
    width: 100%;
    max-width: 390px; /* Match body width */
    padding: 16px; /* p-4 */
    background-color: white;
    border-top: 1px solid #e8ddd4; /* gray-200 border */
    z-index: 40; /* Above main content, below modal */
    box-sizing: border-box; /* Include padding in width */
    }

    .fixed-bottom-bar .content-wrapper { /* Inner wrapper for max-width and gap */
    max-width: 390px; /* Redundant if parent is 390, but good practice */
    margin: 0 auto; /* Redundant if parent is centered, but harmless */
    display: flex;
    gap: 12px; /* gap-3 */
    }

    /* Common button style for the command bar */
    .command-btn {
    flex: 1 1 0%; /* flex-1 */
    padding: 12px 16px; /* py-3 */
    border-radius: 9999px; /* rounded-full */
    font-weight: 700; /* font-bold */
    letter-spacing: 0.025em; /* tracking-wide */
    box-shadow: 0 4px 6px rgba(0,0,0,0.1); /* shadow-md */
    transition: all 0.2s ease; /* transition-all duration-200 */
    cursor: pointer;
    border: none; /* Remove default button border */
    display: flex; /* For icon + text */
    align-items: center;
    justify-content: center;
    gap: 8px; /* gap-2 */
    }

    /* Primary orange button */
    .command-btn.primary {
    background-color: #f97316; /* orange-500 */
    color: white;
    }
    .command-btn.primary:hover {
    background-color: #ea580c; /* hover:bg-orange-600 */
    box-shadow: 0 8px 16px rgba(0,0,0,0.15); /* hover:shadow-lg */
    transform: scale(1.05); /* hover:scale-105 */
    }
    .command-btn.primary:active {
    transform: scale(0.95); /* active:scale-95 */
    }


    /* Add plan button (floating) */
    .add-plan-button {
    position: fixed; /* Changed to fixed */
    bottom: 96px; /* Position from bottom */
    right: 16px; /* Position from right edge of viewport */
    background-color: #F96C50; /* orange-500 */
    color: white;
    width: 56px; /* w-14 */
    height: 56px; /* h-14 */
    border-radius: 9999px; /* rounded-full */
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 30; /* Below fixed bar */
    box-shadow: 0 4px 6px rgba(0,0,0,0.1); /* shadow-md */
    cursor: pointer;
    border: none;
    transition: transform 0.2s ease;
    }
    .add-plan-button:hover {
    transform: scale(1.1); /* Simple hover effect */
    }
    .add-plan-button:active {
    transform: scale(0.95); /* active effect */
    }
    .add-plan-button .lucide {
    pointer-events: none; /* Prevent icon from blocking button */
    }


    /* Modal Overlay */
    .modal-overlay {
    position: fixed;
    inset: 0; /* top:0, right:0, bottom:0, left:0 */
    background-color: rgba(0, 0, 0, 0.5); /* bg-black bg-opacity-50 */
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 16px; /* p-4 */
    z-index: 50; /* Above everything else */
    }

    /* Modal Content */
    .modal-content {
    background-color: white;
    border-radius: 16px; /* rounded-2xl */
    width: 100%;
    max-width: 384px; /* max-w-sm - using 384px */
    padding: 24px; /* p-6 */
    box-shadow: 0 8px 16px rgba(0,0,0,0.15); /* shadow-lg */
    box-sizing: border-box; /* Include padding in width */
    }

    .modal-title {
    font-size: 20px; /* text-xl */
    font-weight: 700; /* font-bold */
    text-align: center;
    margin-bottom: 16px; /* mb-4 */
    }

    .modal-form-group {
    margin-bottom: 16px; /* space-y-4 simulation */
    }
    .modal-form-group:last-child {
    margin-bottom: 0;
    }


    .modal-label {
    display: block;
    margin-bottom: 4px; /* mb-1 */
    font-size: 14px; /* text-sm */
    font-weight: 500; /* font-medium */
    color: #4b5563; /* gray-700 */
    }

    .modal-input {
    width: 100%;
    border: 1px solid #d1d5db; /* border border-gray-300 */
    padding: 8px; /* p-2 */
    border-radius: 4px; /* rounded */
    outline: none;
    box-sizing: border-box; /* Include padding in width */
    }
    .modal-input:focus {
    border-color: #f97316; /* focus:border-orange-500 */
    box-shadow: 0 0 0 3px rgba(253, 186, 116, 0.5); /* focus:ring focus:ring-orange-200 (using rgba for transparency) */
    }

    .modal-time-inputs {
    display: flex;
    align-items: center;
    gap: 8px; /* gap-2 */
    }
    .modal-time-inputs input {
    width: calc(50% - 4px); /* w-1/2 adjusted for gap */
    box-sizing: border-box;
    }


    .modal-emoji-picker {
    display: flex;
    gap: 8px; /* gap-2 */
    flex-wrap: wrap; /* flex-wrap */
    }

    .modal-emoji-button {
    padding: 8px; /* p-2 */
    font-size: 24px; /* text-2xl */
    border-radius: 4px; /* rounded */
    border: none;
    background: none;
    cursor: pointer;
    }

    .modal-emoji-button:hover {
    background-color: #f3f4f6; /* hover:bg-gray-100 */
    }
    .modal-emoji-button.selected {
    background-color: #ffedd5; /* bg-orange-100 */
    }

    .modal-actions {
    margin-top: 24px; /* mt-6 */
    display: flex;
    gap: 12px; /* gap-3 */
    }

    .modal-action-btn {
    flex: 1; /* flex-1 */
    padding: 12px; /* py-3 */
    border-radius: 4px; /* rounded */
    font-weight: 500;
    cursor: pointer;
    border: 1px solid #d1d5db; /* border border-gray-300 */
    background-color: white;
    transition: background-color 0.2s ease;
    }

    .modal-action-btn:hover {
    background-color: #f3f4f6; /* hover:bg-gray-100 */
    }

    .modal-action-btn.primary {
    background-color: #f97316; /* bg-orange-500 */
    color: white;
    border-color: #f97316; /* Match background */
    }
    .modal-action-btn.primary:hover {
    background-color: #ea580c; /* hover:bg-orange-600 */
    }
    </style>
  </head>

  <body className={`bg-gray-100 ${isDraggingOrResizing || showModal || isAiGenerating ? 'no-scroll' : ''}`}>
    <div id="root"></div>

    <script type="text/babel">
    const { useState, useEffect, useRef } = React;

    // Pass showModal prop to header
    function Header({ showModal }) {
      // Using custom .header CSS now
      return (
        <header className={`header ${showModal ? 'blurred' : ''}`}>
          <div className="logo">My Study</div>
          <div className="header-buttons">
            <button
              className="header-btn"
              onClick={(e) => { e.stopPropagation(); window.location.href = "./home.html"; }}
              aria-label="메인화면"
            >
              <i data-lucide="home" className="lucide" style={{ width: 20, height: 20, pointerEvents: 'none' }} /> {/* Add pointer-events: none */}
            </button>
            <button
              className="header-btn"
              onClick={(e) => { e.stopPropagation(); window.location.reload(); }}
              aria-label="새로고침"
            >
              <i data-lucide="refresh-cw" className="lucide" style={{ width: 20, height: 20, pointerEvents: 'none' }} /> {/* Add pointer-events: none */}
            </button>
          </div>
        </header>
      );
    }

    // Component for the Loading Indicator
    const LoadingIndicator = ({ eta }) => (
      <div className="ai-center-container"> {/* Use the flex container for centering */}
        <div className="spinner"></div>
        <div className="loading-text">AI 플랜 생성 중...</div>
        {eta > 0 && <div className="eta-text">예상 완료까지: {eta}초</div>}
        {eta <= 0 && <div className="eta-text">조금만 기다려주세요</div>}
      </div>
    );

    function StudyPlannerApp() {
      // =============== 상수 정의 ===============
      const startHour = 8;
      const endHour = 24;
      const slotHeight30 = 84;
      const slotHeight5 = slotHeight30 / 6;
      const total30Slots = (endHour - startHour) * 2;
      // Include the final endHour time for positioning the very last possible slot
      const timeSlots = Array.from({ length: total30Slots + 1 }, (_, i) => {
        const totalMinutes = startHour * 60 + i * 30;
        const hh = String(Math.floor(totalMinutes / 60)).padStart(2, '0');
        const mm = String(totalMinutes % 60).padStart(2, '0');
        return `${hh}:${mm}`;
      });

      // =============== 상태 정의 ===============
      const [currentView, setCurrentView] = useState('schedule');
      const [userPlans, setUserPlans] = useState([]);
      const [aiPlans, setAiPlans] = useState([]);
      const [isDraggingOrResizing, setIsDraggingOrResizing] = useState(false); // State for drag/resize scroll lock
      const [isAiGenerating, setIsAiGenerating] = useState(false); // State for AI generation loading
      const [aiEtaRemaining, setAiEtaRemaining] = useState(0); // State for AI ETA countdown
      const aiTimerRef = useRef(null); // Ref for AI ETA interval timer


      // 카드 이동/리사이징용 ref
      const resizeDataRef = useRef(null);
      const dragDataRef = useRef(null);

      // Double Tap ref
      const lastTapTimeRef = useRef({}); // Stores timestamp of the last touchstart per plan ID

      // 겹침/원복용 ref
      const currentPlanBeforeDragOrResizeRef = useRef({});

      // 모달 관련 상태
      const [showModal, setShowModal] = useState(false);
      const [editingPlan, setEditingPlan] = useState(null);
      const [newPlan, setNewPlan] = useState({
        title: '',
        memo: '',
        start: '21:00', // Default new plan start time
        end: '22:00',   // Default new plan end time
        emoji: '📚'
      });

      // =============== 초기 로딩 & 상태 저장 ===============
      useEffect(() => {
        const saved = localStorage.getItem("userPlans");
        if (saved) {
          try {
            const loadedPlans = JSON.parse(saved);
            if (Array.isArray(loadedPlans)) {
              // Basic validation: ensure plans have required properties
              const validPlans = loadedPlans.filter(p =>
                p && typeof p.id !== 'undefined' && // Allow id to be number or string (for AI plans)
                  typeof p.title === 'string' &&
                  typeof p.start === 'string' &&
                  typeof p.end === 'string' &&
                  typeof p.emoji === 'string' &&
                  typeof p.done === 'boolean' &&
                  typeof p.duration === 'number' &&
                  typeof p.achievement === 'number'
              );
              setUserPlans(validPlans);
              if (validPlans.length !== loadedPlans.length) {
                console.warn("일부 저장된 플랜 데이터가 유효하지 않아 제외되었습니다.");
              }
            } else {
              console.error("저장된 일정 데이터 형식이 올바르지 않습니다. 초기화합니다.");
              setUserPlans([]); // Reset if data is corrupt
            }
          } catch (e) {
            console.error("저장된 일정 데이터를 불러오지 못했습니다. 초기화합니다.", e);
            setUserPlans([]); // Reset if data is corrupt
          }
        } else {
          // Optional: Initialize with default plans if localStorage is empty
          // setUserPlans([ /* default plans here */ ]);
        }
      }, []); // Run only once on mount

      useEffect(() => {
        // Save user plans to localStorage whenever they change
        localStorage.setItem("userPlans", JSON.stringify(userPlans));

        lucide.createIcons();
      }, [userPlans]); // Save whenever userPlans changes

      useEffect(() => {
        // Scroll to top when switching to AI view
        if (currentView === 'ai') {
          window.scrollTo({ top: 0, behavior: 'smooth' }); // Optional smooth scroll
        }
        // Clear AI plans when switching back from AI view to schedule view
        if (currentView === 'schedule') {
          setAiPlans([]);
        }
      }, [currentView]);

      function timeToInt(t) {
        const [h, m] = t.split(':').map(Number);
        return h * 60 + m;
      }

      // =============== 시간 겹침 검사 ===============
      function isTimeOverlap(newPlan, plans, editingId = null) {
        // Ensure start time is before end time
        const s2TotalMins = timeToInt(newPlan.start);
        const e2TotalMins = timeToInt(newPlan.end);

        if (s2TotalMins >= e2TotalMins) {
          console.warn("Invalid plan times: start is same as or after end.");
          return true; // Overlap if start is same as or after end (or duration is zero/negative)
        }
        // Ensure times are within the valid range (startHour to endHour)
        if (s2TotalMins < startHour * 60 || e2TotalMins > endHour * 60) {
          console.warn(`Plan time out of range: ${newPlan.start} - ${newPlan.end}. Range is ${startHour}:00 - ${endHour}:00`);
          return true; // Treat out of range as overlap for simplicity
        }

        return plans.some(p => {
          if (editingId && p.id === editingId) return false; // Ignore the plan being edited
          const s1TotalMins = timeToInt(p.start);
          const e1TotalMins = timeToInt(p.end);

          // Check for overlap: [s1, e1) and [s2, e2) overlap if max(s1, s2) < min(e1, e2)
          return Math.max(s1TotalMins, s2TotalMins) < Math.min(e1TotalMins, e2TotalMins);
        });
      }

      // =============== 플랜 삭제 & 편집 ===============
      const deletePlan = id => {
        // Prevent deletion if currently dragging/resizing or AI is generating
        if (isDraggingOrResizing || isAiGenerating) return;
        if (window.confirm("정말로 이 플랜을 삭제하시겠습니까?")) {
          setUserPlans(plans => plans.filter(x => x.id !== id));
        }
      };
      const onEdit = plan => {
        // Prevent editing if currently dragging/resizing or AI is generating
        if (isDraggingOrResizing || isAiGenerating) return;
        setEditingPlan(plan);
        setNewPlan({
          title: plan.title,
          memo: plan.memo,
          start: plan.start,
          end: plan.end,
          emoji: plan.emoji
        });
        setShowModal(true);
      };

      // =============== AI 제안 생성 ===============
      const generateAiSuggestions = async () => {
        if (isAiGenerating) return;

        setIsAiGenerating(true);
        setAiPlans([]);
        setAiEtaRemaining(30);
        aiTimerRef.current = setInterval(() => {
          setAiEtaRemaining(prevEta => (prevEta > 0 ? prevEta - 1 : 0));
        }, 1000);
        setCurrentView('ai');

        try {
          const currentPlanForApi = userPlans.map(plan => { return {
            uuid: plan.id,
            emoji: plan.emoji,
            topic: plan.title,
            schedule: {
              start: plan.start + ':00',
              duration_minute: timeToInt(plan.end) - timeToInt(plan.start),
            },
            done: plan.done
          }});

          const postResponse = await fetch("https://doziapi.duckdns.org/api/plan", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            credentials: "include",
            body: JSON.stringify({ plan: currentPlanForApi })
          });

          if (!postResponse.ok) {
            const errorBody = await postResponse.text();
            console.error("API POST failed:", postResponse.status, errorBody);
            throw new Error(`API POST failed with status: ${postResponse.status}`);
          }

          const getResponse = await fetch("https://doziapi.duckdns.org/api/plan");

          if (!getResponse.ok) {
            const errorBody = await getResponse.text();
            console.error("API GET failed:", getResponse.status, errorBody);
            throw new Error(`API GET failed with status: ${getResponse.status}`);
          }

          const suggestionsData = await getResponse.json();

          if (!suggestionsData || !Array.isArray(suggestionsData.plan)) {
            console.error("Invalid API response structure:", suggestionsData);
            throw new Error("Invalid response format from API.");
          }

          const suggestionPlans = suggestionsData.plan.map(suggestion => {
            const start = suggestion.schedule.start.slice(0, 5); // Assuming HH:MM:SS, take HH:MM
            const startTimestamp = timeToInt(start);
            const duration = suggestion.schedule.duration_minute;
            const endTimestamp = startTimestamp + duration;

            // Ensure calculated end time is within the valid range (up to endHour*60)
            const clampedEndTimestamp = Math.min(endTimestamp, endHour * 60);
            // Ensure minimum duration of 5 minutes if possible
            const actualDuration = Math.max(5, clampedEndTimestamp - startTimestamp); // Ensure at least 5 min duration if possible
            const finalEndTimestamp = startTimestamp + actualDuration;


            const endHourStr = String(Math.floor(finalEndTimestamp / 60)).padStart(2, '0');
            const endMinuteStr = String(finalEndTimestamp % 60).padStart(2, '0');
            const end = endHourStr + ':' + endMinuteStr;

            return {
              id: suggestion.uuid,
              emoji: suggestion.emoji,
              title: suggestion.topic,
              memo: '',
              start: start,
              end: end,
            };
          });

          setAiPlans(suggestionPlans);
        } catch (error) {
          console.error("AI plan generation failed:", error);
          alert("AI 플랜 생성에 실패했습니다: " + error.message);
          setAiPlans([]); // Clear AI suggestions on error
          // Stay on schedule view
          setCurrentView('schedule');
        } finally {
          setIsAiGenerating(false); // End loading state
          // Stop the timer
          if (aiTimerRef.current) {
            clearInterval(aiTimerRef.current);
            aiTimerRef.current = null;
          }
          setAiEtaRemaining(0); // Reset ETA
        }
      };

      const applyAiPlans = () => {
        // Prevent applying while AI is regenerating
        if (isAiGenerating) return;

        const newUserPlans = [];
        const userPlansMap = new Map(userPlans.map(plan => [plan.id, plan]));

        for (const aiPlan of aiPlans) {
          const existingUserPlan = userPlansMap.get(aiPlan.id);

          if (existingUserPlan) {
            newUserPlans.push(existingUserPlan);
          } else {
            newUserPlans.push({
              ...aiPlan,
              done: false,
              duration: 0,
              achievement: 0
            });
          }
        }

        newUserPlans.sort((a, b) => {
          const timeA = timeToInt(a.start);
          const timeB = timeToInt(b.start);
          return timeA - timeB;
        });

        setUserPlans(newUserPlans);
        setAiPlans([]); // Clear AI suggestions after applying
        setCurrentView('schedule'); // Switch back to schedule view
      };

      // Delete AI plan suggestion (from the AI list before applying)
      const deleteAiPlan = (id) => {
        setAiPlans(plans => plans.filter(p => p.id !== id));
      };

      // =============== 신규/수정 저장(겹침 검사) ===============
      const savePlan = () => {
        if (!newPlan.title || !newPlan.start || !newPlan.end) {
          alert("할 일, 시작 시간, 종료 시간을 모두 입력해주세요.");
          return;
        }

        const overlap = isTimeOverlap(newPlan, userPlans, editingPlan?.id);
        if (overlap) {
          alert("입력하신 시간이 다른 플랜과 겹치거나 시작 시간이 종료 시간보다 늦습니다.");
          return;
        }
        if (editingPlan) {
          setUserPlans(plans =>
            plans.map(x =>
              x.id === editingPlan.id ? { ...editingPlan, ...newPlan } : x
            )
          );
        } else {
          setUserPlans(plans => [...plans, { ...newPlan, id: crypto.randomUUID(), done: false, duration: 0, achievement: 0 }]);
        }
        setEditingPlan(null); // Clear editing state
        setNewPlan({ title: '', memo: '', start: '21:00', end: '22:00', emoji: '📚' }); // Reset new plan form
        setShowModal(false); // Close modal
      };

      // =============== 카드 리사이즈/이동 로직 (5분 단위) ===============

      // Helper to get coordinates and scroll position from mouse or touch event
      const getCoordsAndScroll = (e) => {
        if (e.touches && e.touches[0]) {
          // Touch event
          return {
            clientX: e.touches[0].clientX,
            clientY: e.touches[0].clientY,
            scrollY: window.scrollY || document.documentElement.scrollTop
          };
        } else if (e.clientX !== undefined) {
          // Mouse event
          return {
            clientX: e.clientX,
            clientY: e.clientY,
            scrollY: window.scrollY || document.documentElement.scrollTop
          };
        }
        return null; // Should not happen
      };


      const startResizing = (e, planId, edge) => {
        if (isAiGenerating) return; // Prevent resizing while AI is generating

        dragDataRef.current = null; // Ensure drag is not active

        const plan = userPlans.find(p => p.id === planId);
        if (!plan) return;

        const coords = getCoordsAndScroll(e);
        if (!coords) return;

        // Store original time for potential revert
        currentPlanBeforeDragOrResizeRef.current[planId] = { start: plan.start, end: plan.end };

        const [sh, sm] = plan.start.split(':').map(Number);
        const totalStartMins = sh * 60 + sm;
        const startIdx5 = (totalStartMins - startHour * 60) / 5;

        const [eh, em] = plan.end.split(':').map(Number);
        const totalEndMins = eh * 60 + em;
        const endIdx5 = (totalEndMins - startHour * 60) / 5;

        // Check if the plan has zero or negative duration before allowing resize
        if (endIdx5 <= startIdx5) {
          console.warn("Cannot resize a plan with zero or negative duration.");
          return;
        }


        resizeDataRef.current = {
          planId,
          edge,
          initialClientY: coords.clientY, // Store clientY from event
          initialScrollY: coords.scrollY, // Store initial scroll position
          initialStartIdx5: startIdx5,
          initialEndIdx5: endIdx5
        };

        setIsDraggingOrResizing(true); // Set dragging/resizing state to true
      };


      const startDragging = (e, planId) => {
        if (isAiGenerating) return; // Prevent dragging while AI is generating

        resizeDataRef.current = null; // Ensure resize is not active

        const plan = userPlans.find(p => p.id === planId);
        if (!plan) return;

        const coords = getCoordsAndScroll(e);
        if (!coords) return;


        // Store original time for potential revert
        currentPlanBeforeDragOrResizeRef.current[planId] = { start: plan.start, end: plan.end };

        const [sh, sm] = plan.start.split(':').map(Number);
        const startIdx5 = ((sh * 60 + sm) - startHour * 60) / 5;

        const [eh, em] = plan.end.split(':').map(Number);
        const endIdx5 = ((eh * 60 + em) - startHour * 60) / 5;

        const durationSlots5 = endIdx5 - startIdx5;
        // Do not start dragging if the plan has zero or negative duration (shouldn't happen with isTimeOverlap check, but safety)
        if (durationSlots5 <= 0) {
          console.warn("Cannot drag a plan with zero or negative duration.");
          return;
        }


        dragDataRef.current = {
          planId,
          initialClientY: coords.clientY, // Store clientY from event
          initialScrollY: coords.scrollY, // Store initial scroll position
          initialStartIdx5: startIdx5,
          durationSlots5
        };

        setIsDraggingOrResizing(true); // Set dragging/resizing state to true
      };


      const onMove = e => {
        // Only proceed if there's an active drag or resize
        if (!dragDataRef.current && !resizeDataRef.current) {
          return;
        }

        const coords = getCoordsAndScroll(e);
        if (!coords) return;

        // Calculate delta Y relative to initial *page* position, accounting for scroll
        const initialClientY = resizeDataRef.current?.initialClientY || dragDataRef.current?.initialClientY;
        const initialScrollY = resizeDataRef.current?.initialScrollY || dragDataRef.current?.initialScrollY;

        // Only proceed if initial coords were captured (should always be if refs are set)
        if (initialClientY === undefined || initialScrollY === undefined) return;


        const deltaY = (coords.clientY + coords.scrollY) - (initialClientY + initialScrollY);
        const deltaSlots5 = Math.round(deltaY / slotHeight5);

        // --- 리사이즈 중일 때 ---
        if (resizeDataRef.current) {
          const { planId, edge, initialStartIdx5, initialEndIdx5 } = resizeDataRef.current;

          let newStartIdx5 = initialStartIdx5;
          let newEndIdx5 = initialEndIdx5;

          if (edge === 'top') {
            newStartIdx5 = initialStartIdx5 + deltaSlots5;
            // Clamp new start index: min 0, max (initialEndIdx5 - 1)
            if (newStartIdx5 < 0) newStartIdx5 = 0;
            if (newStartIdx5 >= initialEndIdx5) newStartIdx5 = initialEndIdx5 - 1; // Ensure min duration of 5 mins
          } else if (edge === 'bottom') {
            newEndIdx5 = initialEndIdx5 + deltaSlots5;
            // Clamp new end index: min (initialStartIdx5 + 1), max total slots
            const total5Slots = ((endHour - startHour) * 60) / 5;
            if (newEndIdx5 <= initialStartIdx5) newEndIdx5 = initialStartIdx5 + 1; // Ensure min duration of 5 mins
            if (newEndIdx5 > total5Slots) newEndIdx5 = total5Slots;
          }

          // Convert indices back to times
          const newStartMins = startHour * 60 + newStartIdx5 * 5;
          const updatedStart = `${String(Math.floor(newStartMins / 60)).padStart(2, '0')}:${String(newStartMins % 60).padStart(2, '0')}`;

          const newEndMins = startHour * 60 + newEndIdx5 * 5;
          const updatedEnd = `${String(Math.floor(newEndMins / 60)).padStart(2, '0')}:${String(newEndMins % 60).padStart(2, '0')}`;

          // Update state immutably only if times actually changed
          setUserPlans(plans => {
            const currentPlan = plans.find(p => p.id === planId);
            if (currentPlan && (currentPlan.start !== updatedStart || currentPlan.end !== updatedEnd)) {
              return plans.map(x =>
                x.id === planId ? { ...x, start: updatedStart, end: updatedEnd } : x
              );
            }
            return plans; // No change needed
          });
          return;
        }

        // --- 이동 중일 때 ---
        if (dragDataRef.current) {
          const { planId, initialStartIdx5, durationSlots5 } = dragDataRef.current;

          let newStartIdx5 = initialStartIdx5 + deltaSlots5;
          const total5Slots = ((endHour - startHour) * 60) / 5;

          // Clamp new start index for dragging
          if (newStartIdx5 < 0) newStartIdx5 = 0;
          if (newStartIdx5 + durationSlots5 > total5Slots) newStartIdx5 = total5Slots - durationSlots5;

          const newEndIdx5 = newStartIdx5 + durationSlots5;

          // Convert indices back to times
          const newStartMins = startHour * 60 + newStartIdx5 * 5;
          const updatedStart = `${String(Math.floor(newStartMins / 60)).padStart(2, '0')}:${String(newStartMins % 60).padStart(2, '0')}`;

          const newEndMins = startHour * 60 + newEndIdx5 * 5;
          const updatedEnd = `${String(Math.floor(newEndMins / 60)).padStart(2, '0')}:${String(newEndMins % 60).padStart(2, '0')}`;

          // Update state immutably only if start time actually changed
          setUserPlans(plans => {
            const currentPlan = plans.find(p => p.id === planId);
            if (currentPlan && currentPlan.start !== updatedStart) {
              return plans.map(x =>
                x.id === planId ? { ...x, start: updatedStart, end: updatedEnd } : x
              );
            }
            return plans; // No change needed
          });
          return;
        }
      };

      // =============== 드래그/리사이즈 종료 시 겹침 검사 및 원복 ===============
      const handleEnd = () => {
        let activeRef = null;
        if(dragDataRef.current) activeRef = dragDataRef.current;
        if(resizeDataRef.current) activeRef = resizeDataRef.current;

        if (activeRef) {
          const { planId } = activeRef;
          const changedPlan = userPlans.find(p => p.id === planId);
          if (changedPlan) {
            // Filter out the plan being moved/resized when checking overlap
            const plansToCheckAgainst = userPlans.filter(x => x.id !== planId);
            if (isTimeOverlap(changedPlan, plansToCheckAgainst)) {
              // 겹치면 원복
              const orig = currentPlanBeforeDragOrResizeRef.current[planId];
              // Only revert if original time exists and is different from current
              if (orig && (changedPlan.start !== orig.start || changedPlan.end !== orig.end)) {
                setUserPlans(plans =>
                  plans.map(x =>
                    x.id === planId
                      ? { ...x, start: orig.start, end: orig.end }
                      : x
                  )
                );
                alert("다른 플랜과 시간이 겹칠 수 없습니다!");
              } else if (!orig) {
                // This case indicates an issue where original time wasn't stored
                console.error(`Original time not stored for plan ${planId}`);
              }
            }
          }
        }
        // Clear refs regardless of overlap check result
        dragDataRef.current = null;
        resizeDataRef.current = null;
        currentPlanBeforeDragOrResizeRef.current = {}; // Clear original times

        setIsDraggingOrResizing(false); // Set dragging/resizing state to false
        // Reset last tap time here in case touch end wasn't part of a double tap
        // This prevents a subsequent single tap from being mistaken for a double tap's second tap.
        lastTapTimeRef.current = {};
      };


      useEffect(() => {
        // Add global mouse and touch event listeners
        window.addEventListener('mousemove', onMove);
        window.addEventListener('mouseup', handleEnd);
        // Use { passive: false } on touchmove to allow preventDefault for stopping scroll
        window.addEventListener('touchmove', onMove, { passive: false });
        window.addEventListener('touchend', handleEnd);
        // Also listen for touchcancel - useful if the touch is interrupted (e.g., multitasking swipe)
        window.addEventListener('touchcancel', handleEnd);


        // Cleanup function to remove listeners
        return () => {
          window.removeEventListener('mousemove', onMove);
          window.removeEventListener('mouseup', handleEnd);
          window.removeEventListener('touchmove', onMove);
          window.removeEventListener('touchend', handleEnd);
          window.removeEventListener('touchcancel', handleEnd);
        };
      }, [userPlans]); // Re-run effect if userPlans state changes (needed because handleEnd uses userPlans)


      // Apply no-scroll class to body based on state
      useEffect(() => {
        const body = document.body;
        // Lock scroll if dragging/resizing OR modal is open OR AI is generating
        if (isDraggingOrResizing || showModal || isAiGenerating) {
          body.classList.add('no-scroll');
        } else {
          body.classList.remove('no-scroll');
        }
        // Cleanup effect
        return () => {
          body.classList.remove('no-scroll'); // Ensure scroll is re-enabled on component unmount
        };
      }, [isDraggingOrResizing, showModal, isAiGenerating]); // Effect depends on these states


      // Effect to manage the AI ETA timer
      useEffect(() => {
        if (isAiGenerating) {
          setAiEtaRemaining(30); // Reset ETA when generation starts
          aiTimerRef.current = setInterval(() => {
            setAiEtaRemaining(prevEta => (prevEta > 0 ? prevEta - 1 : 0));
          }, 1000);
        } else {
          // Stop the timer when generation ends
          if (aiTimerRef.current) {
            clearInterval(aiTimerRef.current);
            aiTimerRef.current = null;
          }
          setAiEtaRemaining(0); // Reset ETA
        }

        // Cleanup interval on component unmount or when isAiGenerating changes to false
        return () => {
          if (aiTimerRef.current) {
            clearInterval(aiTimerRef.current);
            aiTimerRef.current = null;
          }
        };
      }, [isAiGenerating]); // Effect runs when AI generation state changes


      // =============== 렌더링 ===============
      return (
        // The outermost div doesn't need max-w-md mx-auto. Body handles centering.
        // It serves as the main background and container for the whole app UI.
        // Do NOT apply bg-gray-100 here, let body handle it.
        <div className="app-container"> {/* Using a simple class for the main app container */}
          {/* ─────────── 헤더 ─────────── */}
          {/* Header component now contains all necessary styling */}
          <Header showModal={showModal} />

          {/* ─────────── 메인 콘텐츠 (Scrollable Area) ─────────── */}
          {/* This flex container holds the sliding views */}
          <div className="main-content">
            {/* ◼ 스케줄 뷰 */}
            {/* This div slides horizontally */}
            <div className={`view-container schedule-view ${currentView === 'ai' ? 'shifted' : ''}`}> {/* Added shifted class */}
              {/* ─ 시간 슬롯 그리드 (30분 단위만 렌더링) ─ */}
              {/* This div is the actual height driver and scrollable area */}
              {/* Removed overflow-y-auto from here; Body or a wrapper handles overall scroll */}
              {/* Added pb-32 to the grid itself to ensure the last slots are visible above the fixed footer */}
              <div className="time-grid"> {/* Using custom class */}
                {timeSlots.map((time, index) => {
                  const isHour = time.endsWith(':00');
                  // Don't render the last time slot's border if it's the very end (e.g., 24:00)
                  const isLastSlot = index === timeSlots.length - 1;
                  //const isFinalTimeSlot = index === timeSlots.length - 1 && time.endsWith(':00'); // Not used

                  return (
                    <div
                      key={time}
                      className={`time-slot ${isHour ? 'is-hour' : ''} ${!isLastSlot ? 'border-b border-gray-200' : ''}`} /* Using custom classes */
                    >
                      <div className="time-label">{isHour ? time : ''}</div> {/* Using custom class */}
                      <div className="time-content"></div> {/* Using custom class */}
                    </div>
                  );
                })}
              </div>

              {/* ◼ 일정 카드 오버레이 (5분 단위로 위치/높이 조정) */}
              {/* Plan cards are absolutely positioned on top of the time grid */}
              {userPlans.map(plan => {
                const [sh, sm] = plan.start.split(':').map(Number);
                // Convert start time to index (minutes from startHour, divided by 5)
                const startIdx5 = ((sh * 60 + sm) - (startHour * 60)) / 5;

                const [eh, em] = plan.end.split(':').map(Number);
                // Convert end time to index
                const endIdx5 = ((eh * 60 + em) - (startHour * 60)) / 5;

                const spanSlots5 = endIdx5 - startIdx5;
                // Calculate top position and height in pixels based on 5-minute slots
                const topPx = startIdx5 * slotHeight5;
                const heightPx = Math.max(spanSlots5 * slotHeight5, slotHeight5); // Ensure min height of 5 mins


                // Use onTouchStart to record time and initiate drag detection
                // Use onTouchEnd to detect double-tap based on time from start
                const handlePlanTouchStart = (e) => {
                  // Prevent touch if modal is open or AI is generating
                  if (showModal || isAiGenerating) return;

                  // Check if touch started on a resize handle or button
                  if (e.target.closest('.resize-handle') || e.target.closest('button') || e.target.closest('.lucide')) {
                    return; // Let resize/button handlers take over
                  }
                  // Prevent default behavior aggressively to try and stop initial scroll
                  if (e.cancelable) e.preventDefault();
                  e.stopPropagation();

                  lastTapTimeRef.current[plan.id] = Date.now(); // Record touch start time
                  startDragging(e, plan.id); // Start drag detection immediately
                };

                // Mouse down handler for starting drag
                const handlePlanMouseDown = (e) => {
                  // Prevent mouse events if modal is open or AI is generating
                  if (showModal || isAiGenerating) return;

                  // Check if mouse down happened on resize handle or icon button, if so, do nothing
                  if (e.target.closest('.resize-handle') || e.target.closest('button') || e.target.closest('.lucide')) {
                    return; // Let resize/button handlers take over
                  }
                  // Prevent default browser drag behavior
                  if (e.cancelable) e.preventDefault();
                  e.stopPropagation(); // Stop propagation
                  startDragging(e, plan.id);
                };

                return (
                  <div
                    key={plan.id}
                    className={`plan-card ${plan.done ? 'is-done' : ''}`} /* Using custom classes */
                    style={{
                      top: `${topPx}px`,
                      height: `${heightPx}px`,
                    }}
                    // Use onMouseDown and onTouchStart to initiate drag and double-tap check
                    onMouseDown={handlePlanMouseDown}
                    onTouchStart={handlePlanTouchStart}
                    onDoubleClick={() => onEdit(plan)} // Keep double click for desktop
                    // onTouchEnd detects double-tap *after* the touch ends
                    onTouchEnd={(e) => {
                      if (showModal || isAiGenerating) return; // Prevent touch end actions if modal open or AI generating

                      // Check if touch ended on a handle/button
                      if (e.target.closest('.resize-handle') || e.target.closest('button') || e.target.closest('.lucide')) {
                        // Let global handleEnd clear drag/resize state if they were active
                        return;
                      }
                      const now = Date.now();
                      const last = lastTapTimeRef.current[plan.id] || 0;
                      // Check if this touchend is part of a potential double-tap sequence (following a touchstart within 300ms)
                      // Also ensure it wasn't just a very long press/drag (e.g., check if a drag happened)
                      if (now - last < 300 && now - last > 10 && !dragDataRef.current) { // Add a small minimum gap and check if drag occurred
                        // This confirms a double tap (and it wasn't a drag)
                        onEdit(plan); // Trigger edit modal
                      }
                      // Clear the recorded touch start time regardless of double-tap status
                      lastTapTimeRef.current[plan.id] = 0;
                    }}
                  >
                    {/* ◼ 상단 리사이저 (5분 단위 이동) */}
                    <div
                      draggable={false} // Explicitly prevent native HTML drag
                      className="resize-handle top" // Using custom class
                      onMouseDown={e => {
                        if (showModal || isAiGenerating) return; // Prevent resize if modal open or AI generating
                        if (e.cancelable) e.preventDefault(); e.stopPropagation(); startResizing(e, plan.id, 'top');
                      }}
                      onTouchStart={e => {
                        if (showModal || isAiGenerating) return; // Prevent resize if modal open or AI generating
                        if(e.cancelable) e.preventDefault();
                        e.stopPropagation();
                        startResizing(e, plan.id, 'top');
                      }}
                    />

                    {/* ◼ 카드 헤더: 이모지, 제목, 편집/삭제 */}
                    {/* Add pointer-events-none to the container and auto to interactive elements */}
                    <div className="plan-header"> {/* Using custom class */}
                      <div className="plan-title"> {/* Using custom class */}
                        <span className="plan-emoji">{plan.emoji}</span> {/* Using custom class */}
                        <span className="plan-title-text">{plan.title}</span> {/* Using custom class */}
                      </div>
                      <div className="plan-actions"> {/* Using custom class */}
                        {/* Add type="button" and pointer-events: none to icons */}
                        <button onClick={(e) => { e.stopPropagation(); onEdit(plan); }} className="plan-action-btn" type="button"> {/* Using custom class */}
                          <i data-lucide="edit-3" className="lucide" style={{ width: 14, height: 14, pointerEvents: 'none' }} />
                        </button>
                        <button onClick={(e) => { e.stopPropagation(); deletePlan(plan.id); }} className="plan-action-btn" type="button"> {/* Using custom class */}
                          <i data-lucide="trash-2" className="lucide" style={{ width: 14, height: 14, pointerEvents: 'none' }} />
                        </button>
                      </div>
                    </div>

                    {/* ◼ 카드 콘텐츠: 시간표시, 메모 */}
                    {/* Add pointer-events-none to prevent dragging from here, double-tap/drag starts on the outer div */}
                    <div className="plan-content"> {/* Using custom class */}
                      <div className="plan-times">{plan.start} ~ {plan.end}</div> {/* Using custom class */}
                      {plan.memo && <div className="plan-memo">메모: {plan.memo}</div>} {/* Using custom class */}
                    </div>

                    {/* ◼ 하단 리사이저 (5분 단위 이동) */}
                    <div
                      draggable={false} // Explicitly prevent native HTML drag
                      className="resize-handle bottom" // Using custom class
                      onMouseDown={e => {
                        if (showModal || isAiGenerating) return; // Prevent resize if modal open or AI generating
                        if (e.cancelable) e.preventDefault(); e.stopPropagation(); startResizing(e, plan.id, 'bottom');
                      }}
                      onTouchStart={e => {
                        if (showModal || isAiGenerating) return; // Prevent resize if modal open or AI generating
                        if(e.cancelable) e.preventDefault();
                        e.stopPropagation();
                        startResizing(e, plan.id, 'bottom');
                      }}
                    />
                  </div>
                );
              })}
            </div>

            {/* ───────── AI 뷰 ───────── */}
            {/* This div slides horizontally */}
            {/* AI view is active when currentView is 'ai' */}
            <div className={`view-container ai-view ${currentView === 'ai' ? 'active' : ''}`}> {/* Using custom classes */}
              <div className="ai-view-content"> {/* Using custom class */}
                <div className="ai-header"> {/* Using custom class */}
                  <h2 className="ai-title"> {/* Using custom class */}
                    <span>🤖</span> AI 추천 플랜
                  </h2>
                  <button onClick={() => setCurrentView('schedule')} className="ai-back-btn" type="button" disabled={isAiGenerating}> {/* Disable button while generating */}
                    ← 돌아가기
                  </button>
                </div>

                {/* Conditional rendering for Loading Indicator or AI Plans List */}
                {isAiGenerating ? (
                  <LoadingIndicator eta={aiEtaRemaining} />
                ) : (
                    <div className="ai-plans-list"> {/* Using custom class */}
                      {aiPlans.length > 0 ? (
                        aiPlans.map(pl => (
                          <div key={pl.id} className='ai-plan-card'> {/* Using custom class */}
                            {/* AI Plan Content */}
                            <div className="ai-plan-emoji">{pl.emoji}</div> {/* Using custom class */}
                            <div className="ai-plan-details"> {/* Using custom class */}
                              <div className="title">{pl.title}</div> {/* Using custom class */}
                              <div className="time">{pl.start} ~ {pl.end}</div> {/* Using custom class */}
                            </div>
                            {/* Delete Button for AI Plan */}
                            <button
                              className="ai-plan-delete-btn"
                              onClick={(e) => { e.stopPropagation(); deleteAiPlan(pl.id); }}
                              type="button"
                              aria-label="AI 플랜 삭제"
                            >
                              🗙
                            </button>
                          </div>
                        ))
                      ) : (
                          <div className="ai-center-container"> {/* Use the flex container for centering */}
                            <p className="mb-4">🤖 AI에게 오늘의 학습 플랜을 추천받아 보세요!</p> {/* Basic margin */}
                            <button onClick={generateAiSuggestions} className="ai-generate-btn" type="button"> {/* Using custom class */}
                              AI 플랜 생성하기
                            </button>
                          </div>
                        )}
                    </div>
                  )}
              </div>
            </div>
          </div>

          {/* ───────── 하단 명령 바 ───────── */}
          {/* Use the custom class for fixed centering */}
          <div className="fixed-bottom-bar">
            <div className="content-wrapper"> {/* Using custom class */}
              {currentView === 'schedule' ? (
                // Button to switch to AI view and trigger generation
                <button
                  onClick={() => generateAiSuggestions()} // Trigger generation on button click
                  className="command-btn primary" type="button" /* Using custom classes */
                  disabled={isAiGenerating} // Disable button while AI is generating
                >
                  <span style={{ fontSize: '24px' }}>🤖</span> <span>AI 플랜 생성</span> {/* Icon size inline */}
                </button>
              ) : (
                  /* AI View Footer: Only show Apply button if plans exist AND not generating */
                  !isAiGenerating && aiPlans.length > 0 && (
                    <button
                      onClick={applyAiPlans}
                      className="command-btn primary" type="button" /* Using custom classes */
                    >
                      적용
                    </button>
                  )
                )}
            </div>
          </div>

          {/* ───────── 새 일정 추가/수정 모달 ───────── */}
          {showModal && (
            <div className="modal-overlay"> {/* Using custom class */}
              <div className="modal-content"> {/* Using custom class */}
                <h3 className="modal-title">
                  {editingPlan ? '일정 수정' : '새 일정 추가'}
                </h3>
                <div className="modal-form-group"> {/* Using custom class */}
                  <label className="modal-label">할 일</label> {/* Using custom class */}
                  <input
                    type="text"
                    value={newPlan.title}
                    onChange={e => setNewPlan(p => ({ ...p, title: e.target.value }))}
                    className="modal-input" /* Using custom class */
                    placeholder="예: 영어 단어 암기"
                    autoFocus
                  />
                </div>
                <div className="modal-form-group">
                  <label className="modal-label">메모</label>
                  <input
                    type="text"
                    value={newPlan.memo}
                    onChange={e => setNewPlan(p => ({ ...p, memo: e.target.value }))}
                    className="modal-input"
                    placeholder="예: 새 단어 20개"
                  />
                </div>
                <div className="modal-form-group">
                  <label className="modal-label">시간</label>
                  <div className="modal-time-inputs"> {/* Using custom class */}
                    <input
                      type="time"
                      value={newPlan.start}
                      onChange={e => setNewPlan(p => ({ ...p, start: e.target.value }))}
                      className="modal-input" /* Using custom class */
                    />
                    <span>~</span>
                    <input
                      type="time"
                      value={newPlan.end}
                      onChange={e => setNewPlan(p => ({ ...p, end: e.target.value }))}
                      className="modal-input" /* Using custom class */
                    />
                  </div>
                </div>
                <div className="modal-form-group">
                  <label className="modal-label">이모지</label>
                  <div className="modal-emoji-picker"> {/* Using custom class */}
                    {['📚', '✏️', '📐', '🧪', '💡', '💻', '🎨', '🎶', '🎧', '🗣️', '💪', '🛀'].map(em => (
                      <button
                        key={em}
                        onClick={() => setNewPlan(p => ({ ...p, emoji: em }))}
                        className={`modal-emoji-button ${newPlan.emoji === em ? 'selected' : ''}`} /* Using custom classes */
                        type="button"
                      >
                        {em}
                      </button>
                    ))}
                  </div>
                </div>
                <div className="modal-actions"> {/* Using custom class */}
                  <button
                    onClick={() => {
                      setShowModal(false);
                      setEditingPlan(null);
                      setNewPlan({ title: '', memo: '', start: '21:00', end: '22:00', emoji: '📚' });
                    }}
                    className="modal-action-btn" /* Using custom class */
                    type="button"
                  >
                    취소
                  </button>
                  <button onClick={savePlan} className="modal-action-btn primary" type="button"> {/* Using custom classes */}
                    {editingPlan ? '수정 완료' : '추가'}
                  </button>
                </div>
              </div>
            </div>
          )}

          {/* ───────── 새 일정 추가 버튼 ───────── */}
          {/* Fixed button is only shown in schedule view when modal is not open */}
          {!showModal && currentView === 'schedule' && (
            <button
              onClick={() => {
                setEditingPlan(null);
                setNewPlan({ title: '', memo: '', start: '21:00', end: '22:00', emoji: '📚' });
                setShowModal(true);
              }}
              className="add-plan-button" /* Using custom class */
              type="button"
              aria-label="새 일정 추가"
              disabled={isAiGenerating} // Disable button while AI is generating
            >
              <i data-lucide="plus" className="lucide" style={{ width: 24, height: 24, color: 'white', pointerEvents: 'none' }} />
            </button>
          )}
        </div>
      );
    }

    ReactDOM.render(<StudyPlannerApp />, document.getElementById('root'));
    </script>
  </body>

</html>
